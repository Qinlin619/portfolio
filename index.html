<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Interactive Design Portfolio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Google Font -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Poppins", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1a2a6c 0%, #000 55%, #000 100%);
      color: #ffffff;
      overflow-x: hidden;
    }

    /* Top navigation bar */
    header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 64px;
      background: rgba(3, 10, 20, 0.9);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 40px;
      z-index: 10;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    .logo {
      font-weight: 600;
      letter-spacing: 0.12em;
      font-size: 14px;
      text-transform: uppercase;
    }

    nav ul {
      list-style: none;
      display: flex;
      gap: 32px;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
    }

    nav a {
      color: #ffffff;
      text-decoration: none;
      position: relative;
      padding-bottom: 4px;
      opacity: 0.8;
      transition: opacity 0.2s ease;
    }

    nav a::after {
      content: "";
      position: absolute;
      left: 0;
      bottom: 0;
      width: 0%;
      height: 2px;
      background: linear-gradient(90deg, #25c6ff, #ffdd55);
      transition: width 0.25s ease;
    }

    nav a:hover {
      opacity: 1;
    }

    nav a:hover::after {
      width: 100%;
    }

    main {
      margin-top: 64px; /* offset for fixed header */
    }

    /* Hero section */
    .hero {
      position: relative;
      min-height: calc(100vh - 64px);
      width: 100%;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
    }

    #skillGraph {
      position: absolute;
      inset: 0;
    }

    .hero-overlay {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 2;
      pointer-events: none;
    }

    .hero-overlay h1 {
      font-size: clamp(26px, 4vw, 40px);
      font-weight: 600;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      margin-bottom: 10px;
    }

    .hero-overlay p {
      font-size: 14px;
      opacity: 0.8;
      letter-spacing: 0.18em;
      text-transform: uppercase;
    }

    /* Small corner sparkle */
    .corner-sparkle {
      position: absolute;
      right: 40px;
      bottom: 40px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      box-shadow:
        0 0 15px rgba(255, 255, 255, 0.6),
        0 0 30px rgba(144, 202, 249, 0.6);
      opacity: 0.32;
      z-index: 2;
      pointer-events: none;
    }

    @media (max-width: 768px) {
      header {
        padding: 0 16px;
      }

      nav ul {
        gap: 18px;
        font-size: 12px;
      }

      .hero-overlay {
        bottom: 30px;
      }
    }
  </style>
</head>
<body>
<header>
  <div class="logo">INTERACTIVE DESIGNER</div>
  <nav>
    <ul>
      <li><a href="#work">Work</a></li>
      <li><a href="#about">About</a></li>
      <li><a href="#contact">Contact</a></li>
    </ul>
  </nav>
</header>

<main>
  <section class="hero">
    <canvas id="skillGraph"></canvas>
    <div class="hero-overlay">
      <h1>INTERACTIVE DESIGN PORTFOLIO</h1>
      <p>CRAFTING DIGITAL EXPERIENCES</p>
    </div>
    <div class="corner-sparkle"></div>
  </section>
</main>

<script>
/**
 * Simple interactive skill graph
 * - Canvas-based
 * - Nodes connected by thin lines
 * - Nodes can be dragged
 */

(function () {
  const canvas = document.getElementById("skillGraph");
  const ctx = canvas.getContext("2d");
  let width, height, dpr;

  function resize() {
    dpr = window.devicePixelRatio || 1;
    width = canvas.clientWidth || window.innerWidth;
    height = canvas.clientHeight || (window.innerHeight - 64);
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  window.addEventListener("resize", resize);
  resize();

  const skills = [
    { label: "UI/UX RESEARCH", color: "#29b6f6", size: 56, main: true },
    { label: "WIREFRAMING & PROTOTYPING", color: "#66bb6a", size: 40 },
    { label: "MOTION DESIGN", color: "#ff7043", size: 38 },
    { label: "DESIGN SYSTEMS", color: "#ffca28", size: 38 },
    { label: "USABILITY TESTING", color: "#ab47bc", size: 36 },
    { label: "INFORMATION ARCHITECTURE", color: "#7e57c2", size: 36 },
    { label: "INTERACTION DESIGN", color: "#26c6da", size: 34 },
    { label: "CREATIVE CODING", color: "#ec407a", size: 34 },
    { label: "VISUAL STORYTELLING", color: "#ffa726", size: 32 },
    { label: "ACCESSIBILITY", color: "#9ccc65", size: 32 }
  ];

  const nodes = [];
  const links = [];

  const centerX = () => width / 2;
  const centerY = () => height / 2;

  // Create nodes with initial circular layout
  skills.forEach((s, i) => {
    const angle = (i / skills.length) * Math.PI * 2;
    const radius = s.main ? 0 : Math.min(width, height) * 0.28;
    const x = s.main ? centerX() : centerX() + Math.cos(angle) * radius;
    const y = s.main ? centerY() : centerY() + Math.sin(angle) * radius;
    nodes.push({
      label: s.label,
      color: s.color,
      radius: s.size / 2,
      x,
      y,
      vx: (Math.random() - 0.5) * 0.4,
      vy: (Math.random() - 0.5) * 0.4,
      main: !!s.main
    });
  });

  // Create links: connect each non-main node to main + neighbours
  const mainIndex = nodes.findIndex(n => n.main);
  nodes.forEach((node, i) => {
    if (i === mainIndex) return;
    links.push({ source: i, target: mainIndex });
    if (i > 1) links.push({ source: i, target: i - 1 });
    if (i < nodes.length - 1) links.push({ source: i, target: i + 1 });
  });

  // Physics parameters
  const repulsionStrength = 4000;
  const springLength = 150;
  const springStiffness = 0.02;
  const centerPull = 0.02;
  const damping = 0.9;

  // Drag interaction
  let isDragging = false;
  let dragNode = null;
  let mouseX = 0;
  let mouseY = 0;

  function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (evt.clientX - rect.left),
      y: (evt.clientY - rect.top)
    };
  }

  canvas.addEventListener("mousedown", (e) => {
    const pos = getMousePos(e);
    mouseX = pos.x;
    mouseY = pos.y;
    for (let i = nodes.length - 1; i >= 0; i--) {
      const n = nodes[i];
      const dx = pos.x - n.x;
      const dy = pos.y - n.y;
      if (Math.sqrt(dx * dx + dy * dy) <= n.radius + 6) {
        isDragging = true;
        dragNode = n;
        n.vx = 0;
        n.vy = 0;
        break;
      }
    }
  });

  window.addEventListener("mousemove", (e) => {
    if (!isDragging || !dragNode) return;
    const pos = getMousePos(e);
    mouseX = pos.x;
    mouseY = pos.y;
    dragNode.x = mouseX;
    dragNode.y = mouseY;
  });

  window.addEventListener("mouseup", () => {
    isDragging = false;
    dragNode = null;
  });

  // Optional: slight node highlight on hover (cursor)
  canvas.addEventListener("mousemove", (e) => {
    const pos = getMousePos(e);
    let hovering = false;
    for (let n of nodes) {
      const dx = pos.x - n.x;
      const dy = pos.y - n.y;
      if (Math.sqrt(dx * dx + dy * dy) <= n.radius + 6) {
        hovering = true;
        break;
      }
    }
    canvas.style.cursor = hovering ? "grab" : "default";
  });

  function step() {
    // Physics update
    for (let i = 0; i < nodes.length; i++) {
      const n = nodes[i];
      if (n === dragNode) continue;

      // Center attraction
      const cx = centerX();
      const cy = centerY();
      n.vx += (cx - n.x) * centerPull * (n.main ? 1.5 : 1);
      n.vy += (cy - n.y) * centerPull * (n.main ? 1.5 : 1);

      // Repulsion
      for (let j = 0; j < nodes.length; j++) {
        if (i === j) continue;
        const m = nodes[j];
        let dx = n.x - m.x;
        let dy = n.y - m.y;
        let distSq = dx * dx + dy * dy;
        if (distSq === 0) {
          dx = (Math.random() - 0.5) * 0.01;
          dy = (Math.random() - 0.5) * 0.01;
          distSq = dx * dx + dy * dy;
        }
        const force = repulsionStrength / distSq;
        const dist = Math.sqrt(distSq);
        n.vx += (dx / dist) * force;
        n.vy += (dy / dist) * force;
      }
    }

    // Springs
    links.forEach(link => {
      const a = nodes[link.source];
      const b = nodes[link.target];
      let dx = b.x - a.x;
      let dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 0.001;
      const diff = dist - springLength;
      const force = diff * springStiffness;
      const fx = (dx / dist) * force;
      const fy = (dy / dist) * force;

      if (a !== dragNode) {
        a.vx += fx;
        a.vy += fy;
      }
      if (b !== dragNode) {
        b.vx -= fx;
        b.vy -= fy;
      }
    });

    // Integrate
    nodes.forEach(n => {
      if (n === dragNode) return;
      n.vx *= damping;
      n.vy *= damping;
      n.x += n.vx * 0.016;
      n.y += n.vy * 0.016;

      // soft bounds
      const margin = 60;
      n.x = Math.max(margin, Math.min(width - margin, n.x));
      n.y = Math.max(margin, Math.min(height - margin, n.y));
    });

    draw();
    requestAnimationFrame(step);
  }

  function drawBackground() {
    const gradient = ctx.createRadialGradient(
      centerX(), centerY(), 0,
      centerX(), centerY(), Math.max(width, height)
    );
    gradient.addColorStop(0, "rgba(21, 35, 70, 0.9)");
    gradient.addColorStop(0.6, "rgba(2, 6, 23, 1)");
    gradient.addColorStop(1, "rgba(0, 0, 0, 1)");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    // Stars
    ctx.save();
    ctx.fillStyle = "rgba(255, 255, 255, 0.25)";
    for (let i = 0; i < 80; i++) {
      const x = Math.random() * width;
      const y = Math.random() * height;
      const r = Math.random() * 1.5;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  // Pre-generate background once (then we just redraw over it lightly)
  drawBackground();

  function draw() {
    ctx.clearRect(0, 0, width, height);
    drawBackground();

    // Edges
    ctx.save();
    ctx.lineWidth = 0.7;
    ctx.strokeStyle = "rgba(190, 215, 255, 0.35)";
    links.forEach(link => {
      const a = nodes[link.source];
      const b = nodes[link.target];
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    });
    ctx.restore();

    // Nodes
    nodes.forEach(n => {
      const glow = n.main ? 16 : 12;
      ctx.save();
      ctx.shadowBlur = glow;
      ctx.shadowColor = n.color;
      ctx.fillStyle = n.color;
      ctx.beginPath();
      ctx.arc(n.x, n.y, n.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Inner circle
      ctx.save();
      ctx.fillStyle = "rgba(4, 10, 24, 0.95)";
      ctx.beginPath();
      ctx.arc(n.x, n.y, n.radius * 0.82, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Text
      ctx.save();
      ctx.fillStyle = "#ffffff";
      ctx.font = (n.main ? "600 12px 'Poppins'" : "500 11px 'Poppins'");
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      const words = n.label.split(" ");
      const lines = [];
      let line = "";

      words.forEach(word => {
        const testLine = line ? line + " " + word : word;
        const metrics = ctx.measureText(testLine);
        const maxWidth = n.radius * 2.2;
        if (metrics.width > maxWidth && line) {
          lines.push(line);
          line = word;
        } else {
          line = testLine;
        }
      });
      lines.push(line);

      const lineHeight = 14;
      const offsetY = -((lines.length - 1) * lineHeight) / 2;
      lines.forEach((txt, idx) => {
        ctx.fillText(txt, n.x, n.y + offsetY + idx * lineHeight);
      });

      ctx.restore();
    });
  }

  step();
})();
</script>
</body>
</html>
